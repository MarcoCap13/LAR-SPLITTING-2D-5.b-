var documenterSearchIndex = {"docs":
[{"location":"relazione_esecutiva.html#Relazione-II:-studio-esecutivo-LAR-Splitting-2D","page":"Studio Esecutivo","title":"Relazione II: studio esecutivo LAR Splitting 2D","text":"","category":"section"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Studenti: Caponi Marco, Ceneda Gianluca","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Prime analisi, test e possibili ottimizzazioni sul progetto LAR SPLITTING 2D con l’utilizzo della seguente repository:","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Main repository: https://github.com/MarcoCap13/LAR-SPLITTING-2D-5.b-\nhttps://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/master/src/refactoring.jl","category":"page"},{"location":"relazione_esecutiva.html#Obiettivi:","page":"Studio Esecutivo","title":"Obiettivi:","text":"","category":"section"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Studio del progetto LAR SPLITTING 2D e di tutte le funzioni e strutture dati utilizzate.\nDescrizione di ogni task individuata, tipo e significato di ogni parametro ed eventuale valore di ritorno.\nSuddivisione delle tipologie di funzioni e creazione di grafi delle dipendenze.\nIndividuare eventuali problemi riscontrati durante lo studio preliminare del codice.","category":"page"},{"location":"relazione_esecutiva.html#RELAZIONE-DEL-PROGETTO","page":"Studio Esecutivo","title":"RELAZIONE DEL PROGETTO","text":"","category":"section"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"In questa sezione si illustreranno passo passo tutti i vari cambiamenti che sono stati fatti per poter ottimizzare, migliorare il codice e la sua velocità computazionale. Nello specifico abbiamo modificato le funzioni principali della classe Refactoring. Per quanto riguarda la parte precedente del codice, è presente una descrizione accurata nella relazione precedente, visitabile all'indirizzo di seguito: https://github.com/MarcoCap13/LAR-SPLITTING-2D-5.b-/blob/main/relazioni/relazione01.md","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Attraverso lo studio preliminare dei metodi di parallelizzazione, siamo riusciti a migliorare alcune funzioni presenti nelle classi principali attraverso l'utilizzo di alcune macro studiate sul libro consigliato dal professore.","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Per poter analizzare l'efficienza delle varie funzioni, abbiamo utilizzato le seguenti macro:","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"@btime: questa macro svolge lo stesso lavoro di @benchmark ma restituisce un output ","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"meno complesso e più intuitivo, stampando a schermo le velocità di calcolo delle funzioni","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"@benchmark: Ci permette di valutare i parametri della funzione in maniera separata; Richiama la funzione più volte per creare un campione dei tempi di esecuzioni restituendo i tempi minimi, massimi e medi.\n@code_warntype: ci consente di visualizzare i tipi dedotti dal compilatore, identificando così tutte le instabilità di tipo nel codice preso in esame.","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Per quanto riguarda l'ottimizzazione e la parallelizzazione delle funzioni, sono state impiegate le seguenti macro:","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"@threads: l'utilizzo di questa macro è fondamentale per indicare a Julia  la presenza di loop che identificano regioni multi-thread.\n@spawn: identifica uno degli stumenti cardini di Julia per l'assegnazioni dei vari compiti per le task. ","category":"page"},{"location":"relazione_esecutiva.html#Studio-delle-funzioni-ottimizzate","page":"Studio Esecutivo","title":"Studio delle funzioni ottimizzate","text":"","category":"section"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Per vedere nel dettaglio i dati ed i benchmark che riporterò qui di seguito, riporto il link diretto: ","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"https://github.com/MarcoCap13/LAR-SPLITTING-2D-5.b-/tree/main/docs/benchmark ","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"spaceIndex: attraverso lo strumento @codewarntype, è emersa un'instabilità in alcune variabili e non dell'intero metodo. Nel particolare sono _type unstable: bboxes, xboxdict, yboxdict, zboxdict, xcovers, ycovers, zcovers ed infine covers.","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Affinando il codice (in altre parole cercando di eliminare i vari if/else che equivalgono ad una cattiva ottimizzazione del codice) e creando un funzione di supporto denominata removeIntersection abbiamo raggiunto i seguenti risultati.     * Tipo: instabile     * Velocità di calcolo:          * iniziale: 108.350 mus          * modificata: 108.182 mus","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"boundingBox: sempre attraverso l'utilizzo della funzione denominata @codewarntype, è risultata un'instabilità in questo metodo. L'instabilità è dovuta unicamente alla funzione _mapslices.","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Per ovviare a tale problematica abbiamo richiamato la funzione hcat che concatena due array lungo due dimensioni rendendo boundingbox type stable aumentando notevolmente le prestazioni. (per verificarlo abbiamo richiamato @benchmark e comparato i risultati)     * Tipo: instabile     * Velocità di calcolo:          * iniziale:   20.202 mus          * modificata: 13.282 mus","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"boxcovering: boxcovering è type stable ma la variabile covers è un array di Any. Si procede tipizzando covers e dividendo la funzione in microtask.\nTipo: stabile\nVelocità di calcolo: \niniziale:   8.936 mus \nmodificata: 4.499 mus\npointInPolygonClassification: funzione di notevole importanza nel nostro progetto. In questo caso abbiamo scomposto i vari else/if in tante mono-task per poter alleggerire il codice di quest'ultima.","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"Nella figura sottostante vedremo come lavora pointInPolygon, denotando tutti quei segmenti che intersecano le facce del poligono preso in esame. Nello specifico nel punto (a) vediamo i singoli segmenti (o linee) che intersecano quest'ultime; Nel punto (b) vengono illustrati tutti quei punti che sono situati esternamente, internamente o sul bordo della faccia del poligono, nel punto (c) vengono cancellati tutti quei segmenti che vanno verso l'esterno della faccia del poligono e per finire vediamo nel punto (d) il risultato finale attraverso il TGW in 2D.     * Tipo: stabile     * Velocità di calcolo:          * iniziale:   123.196 mus         * modificata: 122.009 mus","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"(Image: Lavoro di pointInPolygonClassification)","category":"page"},{"location":"relazione_esecutiva.html#","page":"Studio Esecutivo","title":"","text":"","category":"section"},{"location":"relazione_esecutiva.html#Funzioni-secondarie-utilizzate-dalle-funzioni-principali:-pointInPolygon,-spaceindex,-boxcovering:","page":"Studio Esecutivo","title":"Funzioni secondarie utilizzate dalle funzioni principali: pointInPolygon, spaceindex, boxcovering:","text":"","category":"section"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"hcat: concatena due array lungo due dimensioni\nmin: restituisce il minimo degli argomenti.\nmax: restituisce il massimo degli argomenti.\nintersect: restituisce l’intersezione di due insiemi.\nenumerate : un iteratore che produce (i, x) dove i è un contatore a partire da 1, e x è il valore i-esimo della collezione su cui scorre l'iteratore dato.\nhaskey : determina se una collezione ha una mappatura per una determinata chiave.\nMapslices: trasforma le dimensioni date dell'array in input usando una funzione scelta dall’utente. La funzione è chiamata su tutte le dimensioni ( slices ) dell’array.","category":"page"},{"location":"relazione_esecutiva.html#Funzioni-aggiuntive-create","page":"Studio Esecutivo","title":"Funzioni aggiuntive create","text":"","category":"section"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"In questa sezione verranno illustrate tutte le funzioni secondarie da noi utilizzate create per migliorare, alleggerire e semplificare gran parte del codice.","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"addIntersection(covers::Array{Array{Int64,1},1}, i::Int64, iterator) aggiunge gli elementi di iterator nell'i-esimo array di covers.\ncreateIntervalTree(boxdict::AbstractDict{Array{Float64,1},Array{Int64,1}}) dato un insieme ordinato, crea un intervalTree; Nel particolare parliamo di una struttura dati che contiene intervalli e che ci consente di cercare e trovare in maniera efficiente tutti gli intervalli che si sovrappongono ad un determinato intervallo o punto.\nremoveIntersection(covers::Array{Array{Int64,1},1}):","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"siamo riusciti a rendere più stabile il tutto diminuendo in linea generale i tempi di calcolo della funzione stessa.  Quest'ultima elimina le intersezioni di ogni boundingbox con loro stessi.","category":"page"},{"location":"relazione_esecutiva.html#Grafo-delle-dipendenze-aggiornato","page":"Studio Esecutivo","title":"Grafo delle dipendenze aggiornato","text":"","category":"section"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"In sintesi, questo grafo rappresenta il lavoro svolto sino ad ora con tutte le nuove funzioni create, aggiornate ed aggiunte. I nodi color celeste sono le funzioni di supporto, i nodi colorati di rosso sono le funzioni principali della classe e gli ultimi colorati di blu sono funzioni secondarie equamente importanti alla fine del progetto stesso. Nello specifico il nodo UtilityfunctionPointInPolygon1-15_  racchiude tutte le 15 funzioni create per il supporto a PointInPolygonclassification.","category":"page"},{"location":"relazione_esecutiva.html","page":"Studio Esecutivo","title":"Studio Esecutivo","text":"(Image: Grafo delle dipendenze della classe Refactoring (Aggiornato))","category":"page"},{"location":"relazione_preliminare.html#Relazione-I:-LAR-Splitting-2D","page":"Studio Preliminare","title":"Relazione I: LAR Splitting 2D","text":"","category":"section"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"Studenti: Caponi Marco, Ceneda Gianluca","category":"page"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"Prime analisi, test e possibili ottimizzazioni sul progetto LAR SPLITTING 2D con l’utilizzo della seguente repository:","category":"page"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"Main repository: https://github.com/MarcoCap13/LAR-SPLITTING-2D-5.b-\nhttps://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/master/src/refactoring.jl","category":"page"},{"location":"relazione_preliminare.html#Obiettivi:","page":"Studio Preliminare","title":"Obiettivi:","text":"","category":"section"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"Studio del progetto LAR SPLITTING 2D e di tutte le funzioni e strutture dati utilizzate.\nDescrizione di ogni task individuata, tipo e significato di ogni parametro ed eventuale valore di ritorno.\nSuddivisione delle tipologie di funzioni e creazione di grafi delle dipendenze.\nIndividuare eventuali problemi riscontrati durante lo studio preliminare del codice.","category":"page"},{"location":"relazione_preliminare.html#Analisi-Preliminare","page":"Studio Preliminare","title":"Analisi Preliminare","text":"","category":"section"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"Lo studio del nostro progetto si basa sull’ottimizzazione delle funzioni principali della classe refactoring tra cui: spaceindex, pointInPolygonClassification e fragmentLines. Nello specifico, ci occupiamo della generazione di una proiezione 2D del piano euclideo di ciascuna faccia, costituita da un insieme di forme solide 3D o da un insieme di primitive 1D (es: linee, poligoni, cerchi etc.).","category":"page"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"Input: In input abbiamo o una struttura LAR, da trasformare in un insieme di poligoni sia 2D che 1D oppure un array formato dagli stessi elementi facente parte dello stesso sistema di coordinate.\nOutput: In output invece abbiamo una collezione di elementi 2D inserite in due matrici diagonali.","category":"page"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"Riassumendo, in questa sezione affronteremo lo studio preliminare delle funzioni principali della classe refactoring:","category":"page"},{"location":"relazione_preliminare.html#Analisi-input-e-output-delle-funzioni:","page":"Studio Preliminare","title":"Analisi input e output delle funzioni:","text":"","category":"section"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"(Image: Grafo delle dipendenze della classe Refactoring)","category":"page"},{"location":"relazione_preliminare.html","page":"Studio Preliminare","title":"Studio Preliminare","text":"CrossingTest: è una funzione di supporto per la funzione primaria pointInPolygonClassification. Aggiorna il count a seconda dello stato identificato come ‘new’ oppure ‘old’, incrementiamo nello specifico di 0.5\nsetTile: è una funzione che imposta il tileCode della bounding box 2D [b1, b2, b3, b4] includendo i \"point\" delle coordinate 2D x, y. A seconda della posizione della variabile ‘point’, tileCode ha un range di 0:15 e usa l’operatore di bit. Successivamente testeremo il codice di TileCode riguardante i bordi di un poligono 2D per determinare se i punti della variabile ‘point’ sono interni, esterni o sono situati sul confine del poligono.\npointInPolygonClassification: questa funzione è fondamentale per identificare se i punti del poligono sono interni, esterni o sono di frontiera (ovvero sul bordo del poligono)\ninput_collection: seleziona una ‘faccia’ e costruisce una collezione di dimensione (d-1). L’output è un input ammissibile per gli algoritmi inerenti alla pipeline 2D/3D\nbounding box: prende in input un vertice di tipo Lar.point (in altre parole una matrice MxN dove M è la dimensione dello spazio in analisi e N è il numero di vertici). La funzione restituisce in output due array che indicano gli estremi del bounding box.\nCoordintervals: funzione che prende in input una matrice (ovvero i bounding box) e un intero che serve a specificare su quale coordinata si vuole lavorare restituendo in output una lista boxdict ordinata. \nBoxcovering: prende in input una matrice (ovvero i bounding box), un intero che indica su quale coordinata si sta lavorando e un ‘intervalTrees’ restituendo una matrice che contiene tutte le intersezioni tra i bounding box.\nSpaceIndex: funzione che prende in input una tupla costituita da una matrice che contiene i punti del modello e da una matrice che contiene le scomposizioni dello spazio geometrico (formato da vertici, lati e facce). Restituisce una matrice covers[k] dove l’elemento k-esimo rappresenta quali intersezioni ha il bounding box (k-esimo) con gli altri bounding box.\nIntersection: funzione che interseca due segmenti nel piano 2D, calcolando i due parametri di linea del punto di intersezione.\nLinefragment: Calcola le sequenze dei parametri ordinati frammentando l’input. Inoltre, i parametri di bordo (0 e 1) sono inclusi nel valore di ritorno dell’output. Il parametro ‘Sigma’ identifica un indice che fornisce un sottoinsieme di linee il cui contenuto interseca il ‘box’ di ciascuna linea di input (identificata dal parametro “EV”)\nFragmentlines: prende in input il modello e anche grazie a spaceindex calcola e restituisce vertici e spigoli di quest’ultimo.\nFragLines: funzione che prende in input degli interi e restituisce una funzione denominata fraglines0 composta da un insieme di vettori\nCongruence: funzione che prende in ingresso un modello di Lar, restituendo una funzione di base denominata hcat che concatena due array lungo due dimensioni.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"% Studio Definitivo Progetto LAR Splitting 2D – CPD22 % Gruppo: 5.b – Caponi Marco 508773, Ceneda Gianluca 488257 % \\today","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Prime analisi, test e possibili ottimizzazioni sul progetto LAR SPLITTING 2D con l’utilizzo della seguente repository:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Main repository: https://github.com/MarcoCap13/LAR-SPLITTING-2D-5.b-\nhttps://github.com/cvdlab/LinearAlgebraicRepresentation.jl/blob/master/src/refactoring.jl","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"\\tableofcontents","category":"page"},{"location":"relazione_definitiva.html#Obiettivi:","page":"Studio Definitivo","title":"Obiettivi:","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Studio del progetto LAR SPLITTING 2D e di tutte le funzioni e strutture dati utilizzate.\nDescrizione di ogni task individuata, tipo e significato di ogni parametro ed eventuale valore di ritorno.\nSuddivisione delle tipologie di funzioni e creazione di grafi delle dipendenze.\nIndividuare eventuali problemi riscontrati durante lo studio preliminare del codice.","category":"page"},{"location":"relazione_definitiva.html#RELAZIONE-DEL-PROGETTO","page":"Studio Definitivo","title":"RELAZIONE DEL PROGETTO","text":"","category":"section"},{"location":"relazione_definitiva.html#Analisi-introduttiva","page":"Studio Definitivo","title":"Analisi introduttiva","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Lo scopo del nostro progetto è stato quello di studiare e dove possibile migliorare attraverso metodi di parallelizzazione le prestazioni dei metodi e delle funzioni riguardante quest'ultimo. Per far ciò ci siamo mossi creando nuove funzioni per alleggerire il codice, effettuando refactoring e applicando delle macro per poter gestire il tutto.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Per vedere le differenze di prestazioni tra una versione e un'altra abbiamo usato due computer con caratteristiche hardware diverse e per alcune funzioni abbiamo utilizzato la workstation DGX-1 messa a disposizione dal dipartimento di  matematica e fisica di roma tre. le differenze notate tra il computer meno performante e quello più performante sono state notevoli. Per quanto riguarda la parte precedente del codice, è presente una descrizione accurata dei vari dati acquisiti attraverso i nostri calcolatori e descritti nella relazione precedente, visitabile all'indirizzo qui di seguito: \\newline https://github.com/MarcoCap13/LAR-SPLITTING-2D-5.b-/blob/main/relazioni/relazione02.md","category":"page"},{"location":"relazione_definitiva.html#Metodi-di-parallelizzione-usati","page":"Studio Definitivo","title":"Metodi di parallelizzione usati","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Abbiamo continuato il nostro studio sulle macro per poter parallelizzare e migliorare la velocità computazionale delle varie funzioni. Nello specifico ci siamo soffermati questa volta sullo studio delle seguenti macro:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"@views: con views si possono creare delle viste degli array che ci permettono di accedere ai valori di quest'ultimo senza effettuare nessuna copia\n@btime: questa macro svolge lo stesso lavoro di @benchmark ma restituisce un output ","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"meno complesso e più intuitivo, stampando a schermo le velocità di calcolo delle funzioni","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"@benchmark: Ci permette di valutare i parametri della funzione in maniera separata; Richiama la funzione più volte per creare un campione dei tempi di esecuzioni restituendo i tempi minimi, massimi e medi.\n@code_warntype: ci consente di visualizzare i tipi dedotti dal compilatore, identificando così tutte le instabilità di tipo nel codice preso in esame.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Per quanto riguarda l'ottimizzazione e la parallelizzazione delle funzioni, sono state impiegate le seguenti macro:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"@threads: l'utilizzo di questa macro è fondamentale per indicare a Julia  la presenza di loop che identificano regioni multi-thread.\n@spawn: identifica uno degli stumenti cardini di Julia per l'assegnazioni dei vari compiti per le task. \n@async: questa macro crea e pianifica le attività per tutto il codice all'inteno della sua attività. E' similare alla macro @spawn con la differenza che runna le task solo a livello locale senza aspettare che il task termini.\n@sync il suon funzionamento è l'opposto del precedente; Aspetta che tutti i task convolti nella parallelizzazione siano completati prima di poter proseguire a livello computazionale.","category":"page"},{"location":"relazione_definitiva.html#Studio-delle-funzioni-ottimizzate","page":"Studio Definitivo","title":"Studio delle funzioni ottimizzate","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Per vedere nel dettaglio i nuovi dati ed i benchmark riporto il link diretto: ","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"https://github.com/MarcoCap13/LAR-SPLITTING-2D-5.b-/tree/main/docs/benchmark","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Lo studio preliminare del progetto è iniziato dalla comprensione del codice per capire come funzionasse lo splitting 2D per poi essere in grado di manipolare le strutture ad esso associate. Dopo di che si è passati allo studio delle funzioni più importanti come spaceindex e pointInPolygonClassification attraverso varie simulazioni delle stesse evidenziando così un'instabilità di tipo su alcune sue variabili grazie all'uso della macro @codewarntype_ citata poco fa, oltre ad una velocita di esecuzione non proprio ottimale. Per risolvere questi problemi, si sono dovute studiare tutte le singole sotto-funzioni in particolare quelle che sollevavano l'instabilità sul tipo:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"spaceIndex: attraverso lo strumento @codewarntype, è emersa un'instabilità in alcune variabili e non dell'intero metodo. Nel particolare sono _type unstable: bboxes, xboxdict, yboxdict, zboxdict, xcovers, ycovers, zcovers ed infine covers.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Parallelizzando il codice e creando un funzione di supporto denominata removeIntersection per poter alleggerire il codice stesso, abbiamo raggiunto i seguenti risultati con un notevole miglioramento.     * Tipo: instabile     * Velocità di calcolo:          * iniziale: 116 mus          * modificata (con workstation DGX-1): 74.8 mus","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"boundingBox: attraverso l'utilizzo della funzione denominata @codewarntype, è risultata un'instabilità in questo metodo. L'instabilità è dovuta unicamente alla funzione _mapslices.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Per ovviare a tale problematica abbiamo richiamato la funzione hcat che concatena due array lungo due dimensioni rendendo boundingbox type stable aumentando notevolmente le prestazioni. (per verificarlo abbiamo richiamato @benchmark e comparato i risultati)     * Tipo: instabile     * Velocità di calcolo:          * iniziale:  9.38 mus          * modificata (con workstation DGX-1): 8.21 mus","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Altre sotto-funzioni type stable invece sono state studiate per comprendere il funzionamento del codice e analizzare i tempi di esecuzione:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"boxcovering: boxcovering è type stable ma la variabile covers è un array di Any. Si procede tipizzando covers e dividendo la funzione in microtask.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Per parallelizzare questa funzione abbiamo utilizzato la funzione @Thread e aggiunto due funzioni di supporto che illustreremo in seguito:  createIntervalTree e addIntersection.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"* Tipo: stabile\n* Velocità di calcolo: \n    * iniziale:   8.936 $\\mu$s \n    * modificata (con workstation DGX-1): 4.46 $\\mu$s","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"coordintervals:Attraverso la macro @codewarntype_ è stata individuata la stabilità di quest'ultima.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"La funzione è risultata molto semplice e qualsiasi intervento svolto, non ha portato a grossi miglioramenti. Abbiamo utilizzato la macro @inbounds ma non ha portato a notevoli stravolgimenti.     * Tipo: stabile     * Velocità di calcolo:          * iniziale:   958.143 ns         * modificata: 1.029 mus  ","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"fragmentlines:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Abbiamo convertito alcune list comprehension in cicli del tipo for i=1:n .. in modo da poter utilizzare la macro @inbounds per disabilitare il boundchecking del compilatore.  L'inserimento esplicito della macro simd non ha comportato alcun beneficio, infatti come si apprende dal sito ufficiale Julia: \"Note that in many cases, Julia can automatically vectorize code without the @simd macro\".  Per quanto riguarda la macro @inbounds,invece, ha ridotto leggermente il numero di allocazioni in memoria.  Nel complesso non sono stati rilevati miglioramenti riguardo le prestazioni della versione iniziale e modificata.  Utilizzando la workstation DGX-1 non abbiamo riscontrato migliorameti importanti.     * Tipo: stabile     * Velocità di calcolo:          * iniziale:   196.813 mus         * modificata: 197.939 mus ","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"linefragment:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Per quanto riguarda quest'ultima funzione, sono stati riscontrati notevoli miglioramenti a livello di prestazioni utilizzando la macro @threads     * Tipo: stabile     * Velocità di calcolo:          * iniziale:   66.414 mus         * modificata: 33.001 mus ","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"congruence:funzione che prende in ingresso un modello di Lar, restituendo una funzione di base denominata hcat che concatena due array lungo due dimensioni. Le macro utilizzate sono @threads e @inbounds. Si nota un certo miglioramento se utilizziamo dei filter per i dati di EV\nTipo: stabile\nVelocità di calcolo: \niniziale:   36.8 mus\nmodificata (workstation DGX-1): 19.6 mus ","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"pointInPolygonClassification: funzione di notevole importanza nel nostro progetto. In questo caso abbiamo scomposto i vari else/if in tante mono-task per poter alleggerire il codice.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Attraverso l'utilizzo della macro @async abbiamo riscontrato un leggero  miglioramento rispetto alla funzione iniziale. ","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Tipo: stabile\nVelocità di calcolo: \niniziale:   82.6 mus\nmodificata: 81.1 mus ","category":"page"},{"location":"relazione_definitiva.html#Funzionamento-dello-splitting","page":"Studio Definitivo","title":"Funzionamento dello splitting","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Nella figura sottostante vedremo come lavora pointInPolygon e il funzionamento dello splitting, denotando tutti quei segmenti che intersecano le facce del poligono preso in esame nel piano z=0. Nello specifico nel punto (a) vediamo i singoli segmenti (o linee) che intersecano il poligono; Nel sezione (b) vengono illustrati tutti quei punti che sono situati esternamente, internamente o sul bordo della faccia del poligono e nel punto (c) vengono cancellati tutti quei segmenti che vanno verso l'esterno della faccia del poligono mentre per finire vediamo nel punto (d) il risultato finale dello splitting.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"\\newpage","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"(Image: Lavoro di pointInPolygonClassification) ","category":"page"},{"location":"relazione_definitiva.html#Esempio-dello-splitting","page":"Studio Definitivo","title":"Esempio dello splitting","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Riportiamo un esempio di splitting effettuato durante lo studio definitivo del progetto attraverso due screenshot fondamentali:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"(Image: Lavoro di splitting (1)) (Image: Lavoro di splitting (2))","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Nella prima figura (di sinistra) vediamo le intersezioni del bounding-box i-esimo con i restanti boundingbox e nella seconda figura vediamo la generazione dei punti dell'intersezioni tra le varie parti.","category":"page"},{"location":"relazione_definitiva.html#Funzioni-aggiuntive-create","page":"Studio Definitivo","title":"Funzioni aggiuntive create","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"In questa sezione verranno illustrate tutte le funzioni secondarie da noi utilizzate create per migliorare, alleggerire e semplificare gran parte del codice.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"addIntersection(covers::Array{Array{Int64,1},1}, i::Int64, iterator) aggiunge gli elementi di iterator nell'i-esimo array di covers.\ncreateIntervalTree(boxdict::AbstractDict{Array{Float64,1},Array{Int64,1}}) dato un insieme ordinato, crea un intervalTree; Nel particolare parliamo di una struttura dati che contiene intervalli e che ci consente di cercare e trovare in maniera efficiente tutti gli intervalli che si sovrappongono ad un determinato intervallo o punto.\nremoveIntersection(covers::Array{Array{Int64,1},1}):","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"siamo riusciti a rendere più stabile il tutto diminuendo in linea generale i tempi di calcolo della funzione stessa.  Quest'ultima elimina le intersezioni di ogni boundingbox con loro stessi.","category":"page"},{"location":"relazione_definitiva.html#Test-delle-funzioni-principali-e-aggiuntive","page":"Studio Definitivo","title":"Test delle funzioni principali e aggiuntive","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"inizialmente si sono eseguiti i test pre-esistenti per verificare il corretto funzionamento delle funzioni principali anche dopo aver effettuato lo studio di parallelizzazione con le macro dei singoli task. Dopo aver verificato il successo di questi, si è proceduto alla realizzazione di nuovi test:","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"@testset \"createIntervalTree test\": creato un OrderedDict e un intervaltrees vogliamo testare che i dati siano stati disposti nel giusto ordine nella struttura dati. Per farlo estraiamo i singoli valori e li confrontiamo con i valori che ci aspettiamo di trovare nelle singole locazioni.\n@testset \"removeIntersection test\": avendo isolato il task della funzione spaceindex che rimuove le intersezioni dei singoli boundingbox con se stesso, vogliamo assicurarci che funzioni nel modo corretto. Per farlo creiamo un array covers di test e controlliamo che la funzione modifichi la struttura dati nel modo corretto per ogni valore.\n@testset \"addIntersection test\": avendo isolato il task della funzione boxcovering che aggiunge in 'covers' in i-esima posizione tutti i bounding box che intersecano l'i-esimo bounding box, vogliamo assicurarci che funzioni nel modo corretto. Per farlo creiamo un boundingbox di test e un OrderedDict con cui creare un intervalTree. A questo punto diamo queste variabili come input alla nostra funzione e confrontiamo il risultato ottenuto con quello atteso.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Per quanto rigurdano i test delle funzioni principali da noi studiate, abbiamo svolto con successo i test sulle funzioni iniziali ricevendo i risultati aspettati. Solo successivamente (con un po' di difficoltà) abbiamo svolto i test sulle funzioni da noi modificate arrivando alla completa correttezza di quest'ultimi. nello specifico si possono revisionare i vari test nei vari notebook  aggiornati, seguendo il link qui riportato: \\newline https://github.com/MarcoCap13/LAR-SPLITTING-2D-5.b-/tree/main/notebook","category":"page"},{"location":"relazione_definitiva.html#Considerazioni-finali-sulla-parallelizzazione","page":"Studio Definitivo","title":"Considerazioni finali sulla parallelizzazione","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"Durante lo studio preliminare ed esecutivo, abbiamo cercato di ottimizzare il nostro codice sia a livello di CPU che GPU. Considerato questo, abbiamo deciso di concentrarci maggiormente sulla parallelizzazione su CPU poichè uno dei pc utilizzati per il progetto era sprovvisto di una GPU dedicata. Per la parallelizzazione su CPU abbiamo utilizzato maggiormente le macro sopra elencate: @threads e @spawn. La prima viene usata su un ciclo for per dividere lo spazio di iterazione su più thread secondo una certa politica di scheduling, mentre la seconda permette di eseguire una funzione su un thread libero nel momento dell'esecuzione. @threads viene usata nella funzione removeIntersection(), boxcovering() e infine in addIntersection(), mentre @spawn viene usata principalmente nella funzione spaceindex(). Per eseguire questo tipo di parallelizzazione bisogna tenere conto del numero di core presenti sulla macchina e proprio per questo motivo abbiamo provato a lavorare con la workstation DGX-1 di nvidia  per poter raggiungere prestazioni migliori. Anche con ciò, si è notato che utilizzare un numero di thread maggiore di quelli disponibili non porta ad un aumento delle prestazioni. Il numero di thread da assegnare ai vari processi julia va stabilito prima dell'avvio e può essere controllato e settato tramite la funzione nthreads(). Successivamente abbiamo testato le prestazioni di spaceindex e pointInPolygon,le funzioni più importanti per lo splitting. Nello specifico abbiamo visto cosa accadeva al variare del numero di thread, in particolare, quando si hanno a disposizione uno, quattro o otto thread (il massimo ottenibile dalla worksation DGX). Analizzando i tempi, si evince che il numero di thread deve essere scelto in base alla complessità del modello preso in esame. Infatti, utilizzando modelli semplici, un numero elevato di thread porta ad un peggioramento delle prestazioni, mentre all'aumentare della complessità si ha un miglioramento.","category":"page"},{"location":"relazione_definitiva.html#Grafo-delle-dipendenze-aggiornato","page":"Studio Definitivo","title":"Grafo delle dipendenze aggiornato","text":"","category":"section"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"In sintesi, questo grafo rappresenta il lavoro svolto sino ad ora con tutte le nuove funzioni create, aggiornate ed aggiunte. I nodi color celeste sono le funzioni di supporto, i nodi colorati di rosso sono le funzioni principali della classe e gli ultimi colorati di blu sono funzioni secondarie equamente importanti alla fine del progetto stesso. Nello specifico il nodo UtilityfunctionPointInPolygon1-15_  racchiude tutte le 15 funzioni create per il supporto a PointInPolygonclassification.","category":"page"},{"location":"relazione_definitiva.html","page":"Studio Definitivo","title":"Studio Definitivo","text":"(Image: Grafo delle dipendenze della classe Refactoring (Aggiornato))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Nome Matricola E-mail Profilo GitHub\nMarco Caponi 508773 MAR.CAPONI4@stud.uniroma3.it https://github.com/MarcoCap13\nGianluca Ceneda 488257 gia.ceneda@stud.uniroma3.it https://github.com/GigiCene95","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Progetto di calcolo parallelo e distribuito dell'anno accademico 2021/2022 svolto dal Gruppo 5.b ","category":"page"}]
}
